#!/usr/bin/env ruby


#
# somafm-cli - Commandline wrapper for playing SomaFM channels using mpv
#
# version 0.0.1
# bgraf <bgraf@uos.de>
#


require 'rexml/document'
require 'net/http'
require 'pp'
require 'yaml'

NAME = "somafm-cli" # name for config and cache subdirectories
CONFIG_DIR = ENV["XDG_CONFIG_HOME"] || File::join(ENV["HOME"], ".config")
CACHE_DIR = ENV["XDG_CACHE_HOME"] || File::join(ENV["HOME"], ".cache")
CMDS = [ :get, :set, :list, :update, :play ]
SOMA_CHANNEL_URL  = "http://somafm.com/channels.xml"
SOMA_SONGS_URL    = "http://somafm.com/songs"
UPDATE_INTERVAL   = 30 #seconds
PLAYLIST_QUALITY  = {"highest" => 2,
                     "fast"    => 1,
                     "slow"    => 0}
PLAYLIST_FORMAT   = {"mp3"     => 2,
                     "aac"     => 1,
                     "aacp"    => 1}


@config =
  { :defchan => nil,
    :playcmd  => 'mpv -playlist %s'
  }


def config_path(filename)
  File::join(File::join(CONFIG_DIR, NAME), filename))


def cache_path(filename)
  File::join(File::join(CACHE_DIR, NAME), filename)


def sort_playlists(playlists)
  playlists.sort_by do |elem|
    quality, format, _ = elem
    0 - (10 * (PLAYLIST_QUALITY[quality] || 0)
        + (PLAYLIST_FORMAT[format] || 0))
  end
end


def channels_of_xml(data)
  doc = REXML::Document.new data

  channels = {}
  doc.elements.each('channels/channel') do |elt|
    hash = {}
    playlists = []
    elt.elements.each do |attr|
      if PLAYLIST_QUALITY.key? attr.name[0..-4] then
        playlists << [attr.name[0..-4], attr.attributes["format"], attr.text]
      else
        hash[attr.name] = attr.text
      end
    end
    id = elt.attributes["id"]
    hash["id"] = id
    hash["playlists"] = sort_playlists(playlists)
    channels[id] = hash
  end
  channels
end


def songs_of_xml(data)
  doc = REXML::Document.new data

  songs = []
  doc.elements.each('songs/song') do |elt|
    hash = {}
    elt.elements.each do |attr|
      hash[attr.name] = attr.text
    end
    songs << hash
  end
  songs
end


def http_get(url)
  Net::HTTP.get_response(URI.parse(url)).body
end


def print_usage_and_exit
  ["Usage: somafm play <name>     - play channel <name>",
   "       somafm list            - show available channels",
   "       somafm update          - manually update channel list",
   "       somafm set <key> <val> - change setting of config variable <key>",
   "       somafm get             - show current configuration settings"
  ].each {|e| puts e }
  exit 0
end


def generate_bash_completion(channels)
  ids = channels.keys
  File.open(cache_path("bash-completion")), 'w')) do |f|
    f.write(
     ["_somafm()",
      "{",
      "local cur prev",
      "COMPREPLY=()",
      "cur=${COMP_WORDS[$COMP_CWORD]}",
	  "prev=${COMP_WORDS[COMP_CWORD-1]}",
	  "cmds='update list play set get'",
	  "case \"${prev}\" in",
	  "    play)",
	  "        COMPREPLY=( $(compgen -W #{ids.join(' ')} -- ${cur}) )",
	  "        return 0",
	  "        ;;",
	  "    set)",
	  "        COMPREPLY=( $(compgen -W #{config.keys} -- ${cur}) )",
	  "        return 0",
	  "        ;;",
	  "    *)",
	  "    ;;",
	  "esac",
      "COMPREPLY=( $( compgen -W \"${cmds}\" -- $cur ) )",
      "return 0",
      "}",
      "complete -F _somafm somafm"
     ].join("\n")
	r)
  end
end


def update_channels
  print "Loading channel list from #{SOMA_CHANNEL_URL}... "
  data = http_get SOMA_CHANNEL_URL
  File.open(cache_path("channels", 'w') {|f| f.write(data) }
  generate_bash_completion(channels_of_xml(data))
end


def read_channels
  file = cache_path("channels")
  if not File.exist? file then
    print "Channel list not found, updating ... "
	update_channels
  end
  data = File.new(path).read
  channels_of_xml(data)
end


def update_songs(id)
  url = "#{SOMA_SONGS_URL}/#{id}.xml"
  http_get url
end


def print_song(song)
  puts Time.at(song["date"].to_i).to_s
  puts " Title:  #{song["title"]}"
  puts " Artist: #{song["artist"]}"
  puts " Album:  #{song["album"]}"
  puts ""
end


def print_songs_since(songs, time)
  songs.select{|e| e["date"].to_i > time}.reverse_each do |e|
    print_song e
  end

end


def loop_songprint(chan)
  id = chan["id"]
  start_time = 0
  while true do
    data = update_songs(id)
    songs = songs_of_xml(data)
    if start_time == 0 then
      print_song songs[0]
    else
      print_songs_since(songs, start_time)
    end
    start_time = songs[0]["date"].to_i

    sleep UPDATE_INTERVAL
  end
end


def start_player(chan)
  _,_,pls = chan["playlists"][0]

  pid = spawn(sprintf(@config[:playcmd], pls), :out=>"/dev/null",:err=>"/dev/null")
  Process.detach(pid)
  trap "SIGINT" do
    Process.kill(:SIGTERM, pid) if pid != nil
    puts "Bye.."
    exit 0
  end

  loop_songprint(chan)
end


def cmd_play
  name = ARGV[1]
  channels = read_channels

  if channels.key? name then
    start_player channels[name]
  else
    puts "Error: no such channel '#{name}'."
    print_usage_and_exit
  end
end


def cmd_list
  channels = read_channels

  channels.keys.sort.each do |id|
    puts "#{id.ljust(15)} #{channels[id]["title"].ljust(25)} #{channels[id]["description"]}"
  end
end


def cmd_set
  key = ARGV[1]
  value = ARGV[2]
  if key not nil and value not nil:
    if key in @config then
	  @config[key] = value
	  return
	end
  end
  print "Not a valid setting, aborting."
end


def cmd_get
  @config.each do |setting|
    puts "#{setting.key} = #{setting.value}"
  end
end


def load_config
  path = config_path(CONFIG_FILE)
  if File::exists? path then
    data = File.open(path).read
    cfg = YAML.load(data)
    @config.merge! cfg
  end
end


def save_config
  path = config_path(CONFIG_FILE)
  File.open(path, 'w') {|f| f.write(YAML.dump @config)}
end


def main
  load_config
  
  cmd = ARGV[0]
  if cmd == nil or cmd not in CMDS then
    print_usage_and_exit
  else
	handler = "cmd_#{cmd}"
	self.send(handler)
  end

  save_config
end


if __FILE__ == $0 then
  main
end
